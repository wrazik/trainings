<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	    <title>constexpr-land</title>

		<link rel="stylesheet" href="../reveal.js/css/reveal.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/league.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../reveal.js/css/print/pdf.css' : '../reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
          <h2> constexpr-land </h2>
					<p>
            evolution &amp; future of constexpr 
					</p>
					<p>
						<small>wrazik, 2019</small>
					</p>
        </section>
        <section>
          <h3> C++ is awesome! </h3>
          <p> You can learn it for many years and it will still suprise you!</p> 
          <img class="fragment" src="img/effective.png" height=400px/>
        </section>
        <section>
          <h2> constexpr </h2>
              <p> It's just a keyword that means that something can be evaluated in constant time </p>
              <p> But even though it looks simple it still may suprise some C++ devs!</p>
        </section>
        <section>
          <h2> constexpr </h2>
              <p> constexpr keyword was added to C++11 </p>
              <p> standard distinguish constexpr in three different places:</p>
              <ul class="fragment"> 
                <li> variable </li>
                <li> function </li>
                <li> constructor </li>
              </ul>
              <p class="fragment"> there is also if constexpr, and metaclass proposal from Herb Sutter with constexpr block </p>
        </section>
        <section>
            <h1> C++11 </h1>
        </section>
        <section>
            <h2> variables </h2>
            <p> must be Literal Type </p> 
            <p> ... what does it mean? </p> 
        </section>
        <section>
            <h2> Literal Type </h2>
            <p>  Literal types are the types of constexpr variable and they can be constructed, manipulated and returned from constexpr function:</p>
            <ul> 
                <li>scalar, reference, array of literal type </li> 
                <li>any cv-qualified class type that has: </li> 
                <ul> 
                    <li> has a trivial destructor </li> 
                    <li> is either an aggregate type or has a constexpr constructor</li> 
                </ul>
            </ul>
        </section>
        <section>
           <h2> Quiz </h2>
           <p> Is this class trivially destructible?</p>
                <pre class="code"><code>struct Foo {
  int i;
  ~Foo() = default;
};
                </code></pre>
                <pre class="code fragment"><code>struct Foo {
  int i;
  ~Foo() {}
};
                </code></pre>
                <pre class="code fragment"><code>struct Foo {
  int i;
  ~Foo();
};
Foo::~Foo() = default;
                </code></pre>
        </section>
        <section>
                <pre class="code"><code>struct Foo {
  ~Foo() = default;
};
struct Bar {
  ~Bar() {};
};
struct FooBar {
  ~FooBar();
};
FooBar::~FooBar() = default;
int main() {
  constexpr Foo f{};    // OK
  constexpr Bar b{};    // Error, non-trivial destructor
  constexpr FooBar b{}; // Error, non-trivial destructor
}
                </code></pre>
        </section>
        <section>
          <p> ...wait, constexpr reference?</p>
                <pre class="code"><code>int main() {
  constexpr int i = 42;
  constexpr const int&amp; j = i; 
  // Error, 'i' is  not a constant expression
}
                </code></pre>
                <p class="fragment"> Yes, but only for objects with static storage duration</p>
                <pre class="code fragment"><code>int main() {
  static constexpr int i = 42;
  constexpr const int&amp; j = i; // OK
}
                </code></pre>
        </section>
        <section>
           <p> Constexpr in object declaration implies const <p>
            <pre class="code"><code>int main() {
  constexpr int i {2};
  static_assert(std::is_same&lt;const int, decltype(i)&gt;::value);
  static_assert(std::is_same&lt;int, decltype(i)&gt;::value); // Error
}</code></pre>
        </section>
        <section>
            <h3> function </h3>
              <p> constexpr function doesn't have to be evaluated at compile time</p>
                <pre class="code"><code>
constexpr int foo(const int i) {
  return i*i;
}

int main(int argc, char** argv) {
  static_assert(foo(5) == 25); // OK
  foo(argc); // OK
}
                </code></pre>
        </section>
        <section>
<p> even if it's not used in constexpr context <b>anywhere</b>, it can't contain expression that can't be evaluated at compile time* </p>
                <pre class="code"><code>
constexpr int foo(const int i) {
  const int x {42}; // Error in C++11, even though
                    // not called in constexpr context
  return x*i;
}

int main(int argc, char** argv) {
  foo(argc);
}
                </code></pre>

        </section>
        <section>
          <p> constexpr function can take only LiteralType arguments, and can return only LiteralType value </p>
          <p> In C++11, we have <i>whitelist</i> of statements that are allowed in constant time context</p>
              <ul> Allowed:
                <li> function can be deleted </li>
                <li> special members can be defaulted </li>
                <li> may contain null statements </li>
              </ul>
                <pre class="code"><code>
constexpr void foo() = delete;
constexpr Foo::Foo() = default;
constexpr void foo() {
    ;
    ;;                        
}
                  </code></pre>
              </section>
          <section>
<p> static_assert </p>

                <pre class="code"><code>
constexpr void foo() {
  static_assert(sizeof(short int) == sizeof(int));
  static_assert(sizeof(int) == sizeof(long int));
}
                </code></pre>
<p> typedefs and alias declarations that do not define classes or enumarations </p>

                <pre class="code"><code>
constexpr void foo() {
  typedef std::string string; // OK, but typedef sucks!
  using MyType = some::fancy_namespace::Type&lt;int&gt;; // Ok
}
                </code></pre>
                <pre class="code"><code>
constexpr void foo() {
  typedef struct Foo {} f; // Error, typedef still sucks
}
                </code></pre>
        </section>
        <section>
<p> using declarations and using directives </p>
                <pre class="code"><code>
constexpr void foo() {
  using namespace std; // using-directive, Ok, but don't do that
  using some::fancy_namespace::Foo; // using-declaration, OK
}
                </code></pre>
        </section>
        <section>
            <p> exactly one return statement</p>
                <pre class="code"><code>
constexpr int Fib(int n) {
  return n &lt; 2 ? 1 : Fib(n-1) + Fib(n-2);
}

int main() {
  static_assert(Fib(6) == 13);
}</code></pre>
        </section>
        <section>
          <p> Note: </p>
          <p> constexpr specifier used in a function implies inline</p>
          <img src="img/godbolt.png"/>
        </section>
        <section>
           <h3> Constructors</h3>
           <p> Each of it's parameters must be Literal Type
           <p> The class must not have virtual base classes </p>
           <p> Can be defaulted, deleted </p>
           <p> The same constraints as for constexpr function, except single return statement </p>
        </section>
        <section>
          <h1> C++14 </h1>
        </section>
        <section>
            <h2> variables </h2>
            <p> constexpr variables has the same requirements as in C++11 </p>
        </section>
        <section>
          <h2> functions </h2>
            <p> Since C++14, we have black list statements <b>not</b> allowed in constexpr context</p>
        </section>
        <section>
            <p> constexpr function in C++14 must <b>not</b> contain: </p>
            <p class="fragment"> assembly block</p>
                <pre class="code fragment"><code>constexpr int foo(int n) {
  asm("movq $60, %rax\n\t" 
      "movq $2,  %rdi\n\t"
      "syscall"); // Not compiling
} </code></pre>
            <p class="fragment"> goto statements </p>
                <pre class="code fragment"><code>constexpr int foo(int n) {
  if (n == 2) 
    goto error; //goto sucks more than typedef
  bar(n);
error:
    make_cleanup();
}</code></pre>
        </section>
        <section>
          <h2>C++14<h2>
        </section>
        <section>
          <h2>C++17<h2>
              <p> constexpr lambda</p>
              <p> if constexpr </p>
              <p constexpr inline variables</p> 
        </section>
        <section>
          <h2>C++20<h2>
              <p> constexpr virtual</p>
<p> constexpr containers: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r5.html</p>
        </section>
        <section>
          <h2>constexpr types<h2>
        </section>
        <section>
          <h2>constexpr new/delete<h2>
<p> try/catch</p>
<p> function try/catch </p>
<p> is_constant_evaluated </p>
<p> </p>
        </section>
        <section>
   
        </section> 
        <section>
          <h2>limitations<h2>
              <p> non-trivial_destructor</p>
              <p> debugging </p>
        </section>
        <section>
          <h2>exceptions<h2>
        </section>
        <section>
          <h2>Compilation<h2>
        </section>
        <section>
          <h1> Questions? </h1>
        </section>
        <section>
          <p>Sources: </p>
          <ul>
            <li> <a href="https://www.youtube.com/watch?v=PJwd4JLYJJY">CppCon 2017: "constexpr ALL the Things"</a></li>
            <li> <a href="https://www.youtube.com/watch?v=JXJg_XMJFW0">C++ Weekly Ep 159 - 'constexpr' 'virtual' Members in C++20</a></li>
            <li> <a href="https://en.cppreference.com/w/cpp/language/constexpr"> cppreference.com </a></li>
            <li> <a href="https://stackoverflow.com/questions/28614591/how-to-initialize-a-constexpr-reference"> stackoverflow.com </a></li>
          </ul>
        </section>
        <section>
          <h1> Thank you! </h1>
        </section>

			</div>
		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: '../reveal.js/plugin/markdown/marked.js' },
					{ src: '../reveal.js/plugin/markdown/markdown.js' },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
